---
- name: Lookup teku user
  getent:
    database: passwd
    key: "{{ teku_user }}"
  register: teku_user_entry
  failed_when: false

- name: Extract current UID (only if user exists)
  set_fact:
    teku_current_uid: "{{ teku_user_entry.ansible_facts.getent_passwd[teku_user][1] | int }}"
  when: not teku_user_entry.failed

- name: Determine if UID update is needed
  set_fact:
    teku_uid_needs_update: "{{ teku_current_uid != teku_uid }}"
  when: not teku_user_entry.failed

- name: Stop enabled teku services if UID needs update
  service:
    name: "{{ item.name }}"
    state: stopped
  loop:
    - name: teku-beacon
      enabled: "{{ teku_beacon_enabled }}"
    - name: teku-validator
      enabled: "{{ teku_validator_enabled }}"
    - name: teku
      enabled: "{{ teku_combined_enabled }}"
  when:
    - item.enabled
    - not teku_user_entry.failed
    - teku_uid_needs_update
  become: true

- name: Set updated optionally to trigger a systemd restart at the end
  set_fact:
    teku_combined_state_updates: "{{ teku_combined_state_updates + (['teku.uid'] if teku_combined_enabled else []) }}"
    teku_state_updates_beacon: "{{ teku_state_updates_beacon + (['teku.uid'] if teku_beacon_enabled else []) }}"
    teku_state_updates_validator: "{{ teku_state_updates_validator + (['teku.uid'] if teku_validator_enabled else []) }}"
  when:
    - not teku_user_entry.failed
    - teku_uid_needs_update

- name: install | Ensure Teku group exists
  ansible.builtin.group:
    name: "{{ teku_group }}"
    gid: "{{ teku_gid }}"    
    state: present
  become: true

- name: install | Create Teku user
  ansible.builtin.user:
    comment: Teku client user
    name: "{{ teku_user }}"
    uid: "{{ teku_uid }}"    
    group: "{{ teku_group }}"
  become: true

- name: install | Create directories
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    owner: "{{ teku_user }}"
    group: "{{ teku_group }}"
  loop:
    - "{{ teku_base_dir }}"
    - "{{ teku_install_dir }}"
    - "{{ teku_config_dir }}"
    - "{{ teku_log_dir }}"
    - "{{ teku_data_dir }}"
    - "{{ teku_validator_data_dir }}"
  become: true

- name: install | Ownership init marker
  ansible.builtin.stat:
    path: "{{ teku_data_dir }}/.ownership_initialized"
  register: ownership_marker

- name: install | Setup logrotate
  ansible.builtin.template:
    src: "logrotate/teku"
    dest: "/etc/logrotate.d/teku"
  become: true

- name: install | Populate service facts
  ansible.builtin.service_facts:

- name: install | Set facts for running Teku services
  ansible.builtin.set_fact:
    teku_beacon_running: "{{ ansible_facts.services['teku-beacon.service'].status == 'enabled' if 'teku-beacon.service' in ansible_facts.services else false }}"
    teku_validator_running: "{{ ansible_facts.services['teku-validator.service'].status == 'enabled' if 'teku-validator.service' in ansible_facts.services else false }}"
    teku_combined_running: "{{ ansible_facts.services['teku.service'].status == 'enabled' if 'teku.service' in ansible_facts.services else false }}"

- name: install | Stop running Teku services
  ansible.builtin.systemd:
    name: "{{ item }}"
    state: "stopped"
  become: true
  loop:
    - teku-beacon.service
    - teku-validator.service
    - teku.service
  register: teku_systemd_stopped
  when: (ansible_facts.services[item] is defined) and
        (ansible_facts.services[item].status == 'enabled')

- name: install | Set updated optionally to trigger a systemd restart at the end - teku_beacon_state_updates
  ansible.builtin.set_fact:
    teku_beacon_state_updates: "{{ teku_beacon_state_updates + ['teku.running_service'] }}"
  when: (item.item == 'teku-beacon.service') and
        (item is defined) and
        (item.state | default('') == "stopped")
  loop: "{{ teku_systemd_stopped.results }}"

- name: install | Set updated optionally to trigger a systemd restart at the end - teku_validator_state_updates
  ansible.builtin.set_fact:
    teku_validator_state_updates: "{{ teku_validator_state_updates + ['teku.running_service'] }}"
  when: (item.item == 'teku-validator.service') and
        (item is defined) and
        (item.state | default('') == "stopped")
  loop: "{{ teku_systemd_stopped.results }}"

- name: install | Set updated optionally to trigger a systemd restart at the end - teku_combined_state_updates
  ansible.builtin.set_fact:
    teku_combined_state_updates: "{{ teku_combined_state_updates + ['teku.running_service'] }}"
  when: (item.item == 'teku.service') and
        (item is defined) and
        (item.state | default('') == "stopped")
  loop: "{{ teku_systemd_stopped.results }}"

- block:
    - name: install | One-time recursive ownership of data dir
      ansible.builtin.file:
        path: "{{ teku_data_dir }}"
        state: directory
        owner: "{{ teku_user }}"
        group: "{{ teku_group }}"
        recurse: true
      become: true

    - name: install | Record that ownership was initialized
      ansible.builtin.copy:
        dest: "{{ teku_data_dir }}/.ownership_initialized"
        content: "initialized: {{ ansible_date_time.iso8601 }}"
        owner: "{{ teku_user }}"
        group: "{{ teku_group }}"
        mode: "0644"
      become: true
  when: not ownership_marker.stat.exists

# Unarchive once if it’s a tarball
# Unarchive twice if it’s an artifact ie a tar in a zip
- name: install | Determine Teku download type
  set_fact:
    _teku_download_base: "/tmp/teku-{{ _teku_version }}"

# case 1 - normal case - release
- block:
    - name: install | Download Teku release tarball
      ansible.builtin.get_url:
        url: "{{ teku_download_url }}"
        dest: "{{ _teku_download_base }}.tar.gz"
        owner: "{{ teku_user }}"
        group: "{{ teku_group }}"
        mode: "0644"
      register: teku_binary_download
      retries: 5
      delay: 10
      until: teku_binary_download is succeeded
      become: true

    - name: install | Extract Teku release to install directory
      ansible.builtin.unarchive:
        src: "{{ _teku_download_base }}.tar.gz"
        remote_src: yes
        dest: "{{ teku_install_dir }}"
        owner: "{{ teku_user }}"
        group: "{{ teku_group }}"
        mode: "0775"
        extra_opts:
          - --strip-components=1
      register: extract_src
      become: true

    - name: install | Remove Teku release tarball
      ansible.builtin.file:
        path: "{{ _teku_download_base }}.tar.gz"
        state: absent
      become: true

  when:
    - not teku_build_from_source
    - teku_download_url.endswith('.tar.gz')

# case 2 - get from gha artifacts
- block:
    - name: install | Normalize Teku artifact API download URL
      set_fact:
        _teku_artifact_api_url: "https://api.github.com/repos/Consensys/teku/actions/artifacts/{{ teku_download_url | regex_search('artifacts/([0-9]+)', '\\1') | first }}/zip"

    # dont use get_url or uri - getting this off azure blob storage is super painful
    - name: install | Download Teku artifact zip (curl)
      ansible.builtin.command: >
        curl -L
        -H "Authorization: Bearer {{ github_teku_token }}"
        -H "Accept: application/vnd.github+json"
        -H "User-Agent: ansible-teku-installer"
        -o {{ _teku_download_base }}.zip
        {{ _teku_artifact_api_url }}
      register: curl_result
      retries: 5
      delay: 10
      until: curl_result.rc == 0
      changed_when: true
      become: true

    - name: install | Create temp dir for Teku artifact extraction
      ansible.builtin.file:
        path: "{{ _teku_download_base }}-artifact"
        state: directory
        mode: "0755"
      become: true

    - name: install | Extract Teku artifact zip
      ansible.builtin.unarchive:
        src: "{{ _teku_download_base }}.zip"
        remote_src: yes
        dest: "{{ _teku_download_base }}-artifact"
      become: true

    - name: install | Find Teku tarball inside artifact
      ansible.builtin.find:
        paths: "{{ _teku_download_base }}-artifact"
        patterns: "*.tar.gz"
        recurse: yes
      register: _teku_artifact_tar

    - name: install | Extract Teku tarball from artifact
      ansible.builtin.unarchive:
        src: "{{ _teku_artifact_tar.files[0].path }}"
        remote_src: yes
        dest: "{{ teku_install_dir }}"
        owner: "{{ teku_user }}"
        group: "{{ teku_group }}"
        mode: "0775"
        extra_opts:
          - --strip-components=1
      register: extract_src
      become: true

    - name: install | Remove Teku artifact zip
      ansible.builtin.file:
        path: "{{ _teku_download_base }}.zip"
        state: absent
      become: true

    - name: install | Cleanup Teku artifact temp dir
      ansible.builtin.file:
        path: "{{ _teku_download_base }}-artifact"
        state: absent
      become: true

  when:
    - not teku_build_from_source
    - not teku_download_url.endswith('.tar.gz')


# case 3 - install from the local build
- block:
    - name: install | Extract Teku (built from source)
      ansible.builtin.unarchive:
        src: "{{ _teku_source_tarball }}"
        remote_src: true
        dest: "{{ teku_install_dir }}"
        owner: "{{ teku_user }}"
        group: "{{ teku_group }}"
        mode: "0775"
        extra_opts:
          - --strip-components=1
      register: extract_src
      become: true

    - name: install | Cleanup Teku source tarball
      ansible.builtin.file:
        path: "{{ _teku_source_tarball }}"
        state: absent
      become: true

  when: teku_build_from_source

## Now that we have the installation done from all these various places
- name: install | Create a symlink to current
  ansible.builtin.file:
    src: "{{ teku_install_dir }}/"
    dest: "{{ teku_current_dir }}"
    state: link
  register: create_symlink
  become: true

- name: install | Set updated optionally to trigger a systemd restart at the end
  ansible.builtin.set_fact:
    teku_combined_state_updates: "{{ teku_combined_state_updates + ['teku.install_dir'] }}"
    teku_validator_state_updates: "{{ teku_validator_state_updates + ['teku.install_dir'] }}"
    teku_beacon_state_updates: "{{ teku_beacon_state_updates + ['teku.install_dir'] }}"
  when: >
    extract_src is changed or
    create_symlink is changed
